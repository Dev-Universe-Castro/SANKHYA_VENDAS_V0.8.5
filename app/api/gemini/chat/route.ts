import { NextRequest } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { cookies } from 'next/headers';
import { redisCacheService } from '@/lib/redis-cache-service';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');

// Fun√ß√£o helper para fetch com timeout
async function fetchWithTimeout(url: string, options: RequestInit = {}, timeoutMs = 15000) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(timeout);
    return response;
  } catch (error) {
    clearTimeout(timeout);
    console.error(`‚ö†Ô∏è Timeout/erro ao buscar ${url}:`, error);
    throw error;
  }
}

// Fun√ß√£o para buscar dados do sistema com filtro de data
async function analisarDadosDoSistema(userId: number, userName: string, isAdmin: boolean = false, filtroFrontend?: { dataInicio: string, dataFim: string }) {
  try {
    // Usar filtro do frontend se dispon√≠vel, sen√£o usar padr√£o: √∫ltimos 90 dias
    let filtro;
    if (filtroFrontend && filtroFrontend.dataInicio && filtroFrontend.dataFim) {
      filtro = filtroFrontend;
    } else {
      const dataFim = new Date();
      const dataInicio = new Date();
      dataInicio.setDate(dataInicio.getDate() - 90);
      filtro = {
        dataInicio: dataInicio.toISOString().split('T')[0],
        dataFim: dataFim.toISOString().split('T')[0]
      };
    }

    console.log('üîç Buscando dados completos do sistema com filtro de data:', filtro);

    // Importar servi√ßo de an√°lise dinamicamente
    const { buscarDadosAnalise } = await import('@/lib/analise-service');

    // Buscar TODOS os dados de uma vez, com cache inteligente
    const dadosCompletos = await buscarDadosAnalise(filtro, userId, isAdmin);

    console.log(`üìä Dados completos carregados:`, {
      leads: dadosCompletos.leads.length,
      atividades: dadosCompletos.atividades.length,
      pedidos: dadosCompletos.pedidos.length,
      produtos: dadosCompletos.produtos.length,
      clientes: dadosCompletos.clientes.length,
      financeiro: dadosCompletos.financeiro.length,
      funis: dadosCompletos.funis.length,
      estagios: dadosCompletos.estagiosFunis.length
    });

    // Calcular m√©tricas
    const valorTotalPedidos = dadosCompletos.pedidos.reduce((sum, p) => sum + (parseFloat(p.VLRNOTA) || 0), 0);
    const valorTotalFinanceiro = dadosCompletos.financeiro.reduce((sum, f) => sum + (parseFloat(f.VLRDESDOB) || 0), 0);
    const valorRecebido = dadosCompletos.financeiro.reduce((sum, f) => sum + (parseFloat(f.VLRBAIXA) || 0), 0);

    // Calcular maiores clientes
    const pedidosPorCliente = dadosCompletos.pedidos.reduce((acc: any, p: any) => {
      const nomeCliente = p.NOMEPARC || p.Parceiro_NOMEPARC || 'Cliente Desconhecido';
      const codParc = p.CODPARC || 'SEM_CODIGO';
      const key = `${codParc}|${nomeCliente}`;

      if (!acc[key]) {
        acc[key] = {
          codigo: codParc,
          nome: nomeCliente,
          total: 0,
          qtdPedidos: 0,
          pedidos: []
        };
      }
      const valor = parseFloat(p.VLRNOTA) || 0;
      acc[key].total += valor;
      acc[key].qtdPedidos += 1;
      acc[key].pedidos.push({
        nunota: p.NUNOTA,
        valor: valor,
        data: p.DTNEG
      });
      return acc;
    }, {});

    const maioresClientes = Object.values(pedidosPorCliente)
      .sort((a: any, b: any) => b.total - a.total)
      .map((c: any) => ({
        codigo: c.codparc,
        nome: c.nome,
        totalPedidos: c.qtdPedidos,
        valorTotal: c.total,
        ticketMedio: c.total / c.qtdPedidos,
        pedidos: c.pedidos
      }));

    return {
      leads: dadosCompletos.leads,
      produtosLeads: dadosCompletos.produtosLeads,
      atividades: dadosCompletos.atividades,
      pedidos: dadosCompletos.pedidos,
      produtos: dadosCompletos.produtos,
      clientes: dadosCompletos.clientes,
      financeiro: dadosCompletos.financeiro,
      funis: dadosCompletos.funis,
      estagiosFunis: dadosCompletos.estagiosFunis,
      userName,
      filtro,
      // M√©tricas calculadas
      totalLeads: dadosCompletos.leads.length,
      totalAtividades: dadosCompletos.atividades.length,
      totalPedidos: dadosCompletos.pedidos.length,
      totalProdutos: dadosCompletos.produtos.length,
      totalClientes: dadosCompletos.clientes.length,
      totalFinanceiro: dadosCompletos.financeiro.length,
      valorTotalPedidos,
      valorTotalFinanceiro,
      valorRecebido,
      valorPendente: valorTotalFinanceiro - valorRecebido,
      maioresClientes // Adicionado aqui
    };
  } catch (error) {
    console.error('‚ùå Erro ao analisar dados do sistema:', error);
    return {
      leads: [],
      produtosLeads: [],
      atividades: [],
      pedidos: [],
      produtos: [],
      clientes: [],
      financeiro: [],
      funis: [],
      estagiosFunis: [],
      userName,
      filtro: { dataInicio: '', dataFim: '' },
      totalLeads: 0,
      totalAtividades: 0,
      totalPedidos: 0,
      totalProdutos: 0,
      totalClientes: 0,
      totalFinanceiro: 0,
      valorTotalPedidos: 0,
      valorTotalFinanceiro: 0,
      valorRecebido: 0,
      valorPendente: 0,
      maioresClientes: [] // Inicializado como array vazio
    };
  }
}

const SYSTEM_PROMPT = `Voc√™ √© um Assistente de Vendas Inteligente da Sankhya.

SEU PAPEL:
- Ajudar vendedores a gerenciar leads e atividades
- Sugerir pr√≥ximas a√ß√µes baseadas no hist√≥rico
- Analisar o pipeline de vendas focando em valores e oportunidades
- Fornecer insights sobre leads e atividades

ESTRUTURA DE DADOS DO SISTEMA:
1. FUNIL: Container de est√°gios de vendas
2. EST√ÅGIOS: Etapas dentro de um funil (ex: Leads, Discovery, Demo, Won)
3. LEADS: Oportunidades de venda dentro de cada est√°gio
4. ATIVIDADES: A√ß√µes relacionadas aos leads (liga√ß√µes, emails, reuni√µes, etc)
5. PEDIDOS: Pedidos de venda finalizados (valor total por cliente)
6. CLIENTES: Base de clientes do sistema

HIERARQUIA:
Funil ‚Üí Est√°gios ‚Üí Leads ‚Üí Atividades/Produtos

VOC√ä TEM ACESSO A:
- Leads e seus est√°gios dentro dos funis
- Atividades registradas (com status: AGUARDANDO, ATRASADO, REALIZADO)
- Produtos vinculados aos leads (itens de interesse de cada lead)
- Base completa de produtos cadastrados no sistema (cat√°logo)
- Clientes cadastrados (CODPARC, nome, CPF/CNPJ)
- Pedidos de venda finalizados com CODPARC (c√≥digo do cliente), nome do cliente e valores totais

FOCO PRINCIPAL:
1. **Atividades**: Analise atividades pendentes, atrasadas e sugest√µes de follow-up
2. **Leads**: Identifique oportunidades priorit√°rias, leads parados, convers√£o entre est√°gios
3. **Pedidos**: Analise valores totais por cliente, ticket m√©dio, tend√™ncias de compra
4. **Pipeline**: Entenda a distribui√ß√£o de leads nos est√°gios e funis

COMO VOC√ä DEVE RESPONDER:
1. Seja direto e focado em a√ß√µes de vendas
2. Use APENAS dados reais do sistema - NUNCA invente n√∫meros ou informa√ß√µes
3. Quando informar quantidades, use EXATAMENTE os n√∫meros fornecidos no contexto
4. Sugira pr√≥ximos passos concretos (ligar, email, reuni√£o)
5. Analise tend√™ncias no pipeline
6. Identifique leads e atividades que precisam de aten√ß√£o

REGRA IMPORTANTE: Se o contexto diz "TOTAL: X", voc√™ DEVE responder com esse n√∫mero exato.

EXEMPLOS DE AN√ÅLISES QUE VOC√ä PODE FAZER:
- "Quais leads t√™m atividades atrasadas?"
- "Mostre oportunidades priorit√°rias por valor"
- "Analise a convers√£o entre est√°gios do funil"
- "Quais clientes geraram mais pedidos?" ‚Üí Use CODPARC dos pedidos
- "Quantos pedidos tenho?" ‚Üí Use o n√∫mero EXATO de pedidos fornecido
- "Pedidos por cliente" ‚Üí Agrupe pedidos usando CODPARC e nome do cliente
- "Principais clientes" ‚Üí Ordene clientes por valor total de pedidos
- "Sugira pr√≥ximas atividades para leads parados"

REGRA CR√çTICA SOBRE PEDIDOS E CLIENTES:
- Os pedidos SEMPRE incluem CODPARC (c√≥digo do cliente) e nome do cliente
- Quando perguntarem sobre pedidos, USE os dados fornecidos no contexto
- NUNCA pe√ßa dados adicionais se eles j√° est√£o no contexto
- O n√∫mero de pedidos est√° CLARAMENTE indicado como "TOTAL EXATO: X pedidos"
- A lista de "MAIORES CLIENTES" j√° est√° TOTALMENTE CALCULADA e DISPON√çVEL
- Se voc√™ ver a se√ß√£o "üèÜ AN√ÅLISE DE CLIENTES POR VALOR TOTAL", significa que os dados J√Å EST√ÉO PRONTOS
- NUNCA responda "preciso dos dados" quando a se√ß√£o de MAIORES CLIENTES estiver presente

IMPORTANTE: Se o contexto cont√©m a lista de MAIORES CLIENTES, voc√™ DEVE usar esses dados diretamente na sua resposta.
N√£o pe√ßa informa√ß√µes que j√° foram fornecidas no contexto.

Sempre forne√ßa informa√ß√µes baseadas nos dados reais dispon√≠veis no contexto.`;

export async function POST(request: NextRequest) {
  try {
    const { message, history, filtro } = await request.json();

    // Obter usu√°rio autenticado
    const cookieStore = await cookies();
    const userCookie = cookieStore.get('user');
    let userId = 0;
    let userName = 'Usu√°rio';
    let isAdmin = false;

    if (userCookie) {
      try {
        const user = JSON.parse(userCookie.value);
        userId = user.id;
        userName = user.name || 'Usu√°rio';
        isAdmin = user.role === 'admin';
      } catch (e) {
        console.error('Erro ao parsear cookie:', e);
      }
    }

    const model = genAI.getGenerativeModel({
      model: 'gemini-2.5-flash',
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 1500,
      }
    });

    // Montar hist√≥rico com prompt de sistema
    const chatHistory = [
      {
        role: 'user',
        parts: [{ text: SYSTEM_PROMPT }],
      },
      {
        role: 'model',
        parts: [{ text: 'Entendido! Sou seu Assistente de Vendas no Sankhya CRM. Estou pronto para analisar seus dados e ajudar voc√™ a vender mais. Como posso ajudar?' }],
      },
      ...history.map((msg: any) => ({
        role: msg.role === 'assistant' ? 'model' : 'user',
        parts: [{ text: msg.content }],
      }))
    ];

    // Adicionar contexto de dados APENAS no primeiro prompt do usu√°rio
    let messageWithContext = message;
    if (history.length === 0) {
      console.log('üîç Primeiro prompt detectado - Buscando dados completos do sistema...');
      const dadosSistema = await analisarDadosDoSistema(userId, userName, isAdmin, filtro);

      if (dadosSistema) {
        // Payload focado em VENDAS (leads, atividades, pedidos)
        messageWithContext = `CONTEXTO DO SISTEMA (${dadosSistema.filtro.dataInicio} a ${dadosSistema.filtro.dataFim}):

üë§ Usu√°rio: ${dadosSistema.userName}

üìä N√öMEROS EXATOS DO SISTEMA (USE ESTES N√öMEROS, N√ÉO INVENTE):
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Üí LEADS: ${dadosSistema.totalLeads}
‚Üí ATIVIDADES: ${dadosSistema.totalAtividades}
‚Üí PEDIDOS: ${dadosSistema.totalPedidos} (Total: R$ ${(dadosSistema.valorTotalPedidos || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })})
‚Üí PRODUTOS CADASTRADOS: ${dadosSistema.totalProdutos}
‚Üí CLIENTES: ${dadosSistema.totalClientes}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üéØ FUNIS E EST√ÅGIOS:
${dadosSistema.funis.map((f: any) => {
  const estagios = dadosSistema.estagiosFunis.filter((e: any) => e.CODFUNIL === f.CODFUNIL);
  const leadsNoFunil = dadosSistema.leads.filter((l: any) => l.CODFUNIL === f.CODFUNIL);
  return `‚Ä¢ ${f.NOME} (${estagios.length} est√°gios, ${leadsNoFunil.length} leads)
  ${estagios.map((e: any) => {
    const leadsNoEstagio = dadosSistema.leads.filter((l: any) => l.CODESTAGIO === e.CODESTAGIO);
    return `  - ${e.NOME}: ${leadsNoEstagio.length} leads`;
  }).join('\n')}`;
}).join('\n')}

${dadosSistema.totalLeads > 0 ? `üí∞ LEADS NO PIPELINE (${dadosSistema.totalLeads}):
${dadosSistema.leads.map((l: any) => {
  const estagio = dadosSistema.estagiosFunis.find((e: any) => e.CODESTAGIO === l.CODESTAGIO);
  const funil = dadosSistema.funis.find((f: any) => f.CODFUNIL === l.CODFUNIL);
  const produtos = dadosSistema.produtosLeads.filter((p: any) => p.CODLEAD === l.CODLEAD);
  return `‚Ä¢ ${l.NOME} - R$ ${(l.VALOR || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}
  Status: ${l.STATUS_LEAD || 'EM_ANDAMENTO'}
  Est√°gio: ${estagio?.NOME || 'Sem est√°gio'} (Funil: ${funil?.NOME || 'Sem funil'})
  ${produtos.length > 0 ? `Produtos: ${produtos.map((p: any) => p.DESCRPROD).join(', ')}` : ''}`;
}).join('\n\n')}` : ''}

${dadosSistema.totalAtividades > 0 ? `üìã ATIVIDADES (${dadosSistema.totalAtividades}):
${dadosSistema.atividades.map((a: any) => {
  const lead = dadosSistema.leads.find((l: any) => l.CODLEAD === a.CODLEAD);
  const desc = a.DESCRICAO?.split('|')[0] || a.DESCRICAO || 'Sem descri√ß√£o';
  const status = a.STATUS || 'AGUARDANDO';
  const tipo = a.TIPO || '';

  // Formatar data corretamente
  let dataFormatada = 'Sem data';
  if (a.DATA_INICIO) {
    try {
      const data = new Date(a.DATA_INICIO);
      if (!isNaN(data.getTime())) {
        dataFormatada = data.toLocaleDateString('pt-BR', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }
    } catch (e) {
      dataFormatada = 'Data inv√°lida';
    }
  } else if (a.DATA_HORA) {
    try {
      const data = new Date(a.DATA_HORA);
      if (!isNaN(data.getTime())) {
        dataFormatada = data.toLocaleDateString('pt-BR', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }
    } catch (e) {
      dataFormatada = 'Data inv√°lida';
    }
  }

  return `‚Ä¢ ${desc.substring(0, 60)}
  Tipo: ${tipo} | Status: ${status} | Data: ${dataFormatada}
  ${lead ? `Lead: ${lead.NOME}` : 'Sem lead associado'}`;
}).join('\n\n')}` : ''}

${dadosSistema.totalPedidos > 0 ? `üíµ PEDIDOS DE VENDA FINALIZADOS:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
TOTAL EXATO: ${dadosSistema.totalPedidos} pedidos
VALOR TOTAL: R$ ${(dadosSistema.valorTotalPedidos || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

${dadosSistema.maioresClientes && dadosSistema.maioresClientes.length > 0 ? `üèÜ AN√ÅLISE DE CLIENTES POR VALOR TOTAL (J√Å CALCULADO):

VOC√ä J√Å TEM TODOS OS DADOS DOS CLIENTES ABAIXO - N√ÉO PE√áA MAIS INFORMA√á√ïES!

Os ${dadosSistema.maioresClientes.length} principais clientes por valor total de pedidos s√£o:

${dadosSistema.maioresClientes.slice(0, 20).map((c: any, idx: number) => `
${idx + 1}¬∫) ${c.nome} (C√≥digo: ${c.codigo})
   ‚Ä¢ Total de Pedidos: ${c.totalPedidos}
   ‚Ä¢ Valor Total: R$ ${(c.valorTotal || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}
   ‚Ä¢ Ticket M√©dio: R$ ${(c.ticketMedio || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}
   ‚Ä¢ Detalhes dos pedidos: ${c.pedidos?.length || 0} pedidos registrados`).join('\n')}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
INSTRU√á√ïES CR√çTICAS:
‚Ä¢ Quando perguntarem "quais os maiores clientes", USE a lista acima
‚Ä¢ Quando perguntarem "principais clientes", USE a lista acima
‚Ä¢ NUNCA pe√ßa mais dados sobre clientes - voc√™ j√° tem TUDO acima
‚Ä¢ Os dados incluem: CODPARC, nome do cliente, valor total, quantidade de pedidos
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ` : 'Nenhum cliente com pedidos'}

FINANCEIRO - T√çTULOS A RECEBER (${dadosSistema.financeiro?.length || 0} total):
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
VALOR TOTAL A RECEBER: R$ ${(dadosSistema.valorTotalFinanceiro || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}
VALOR RECEBIDO: R$ ${(dadosSistema.valorRecebido || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}
VALOR PENDENTE: R$ ${(dadosSistema.valorPendente || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

IMPORTANTE PARA RESPONDER:
‚Ä¢ Quando perguntarem sobre "quantos pedidos", responda: ${dadosSistema.totalPedidos} pedidos
‚Ä¢ Quando perguntarem sobre "principais clientes" ou "maiores clientes", use a lista de MAIORES CLIENTES acima
‚Ä¢ Quando perguntarem sobre "pedidos por cliente", analise a lista de MAIORES CLIENTES acima
‚Ä¢ Os dados de pedidos incluem CODPARC (c√≥digo do cliente) e nome do cliente
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ` : 'Nenhum pedido de venda registrado no per√≠odo.'}

${dadosSistema.totalProdutos > 0 ? `üì¶ CAT√ÅLOGO DE PRODUTOS (BASE COMPLETA):
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
TOTAL EXATO: ${dadosSistema.totalProdutos} produtos cadastrados no sistema
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Exemplos: ${dadosSistema.produtos.slice(0, 5).map((p: any) => p.DESCRPROD).join(', ')}...

IMPORTANTE: Quando o usu√°rio perguntar sobre produtos na base, responda com ${dadosSistema.totalProdutos} produtos.` : 'Nenhum produto cadastrado no sistema.'}

PERGUNTA DO USU√ÅRIO:
${message}`;
        console.log('‚úÖ Contexto anexado (leads, atividades, pedidos, hierarquia funil>est√°gio>lead, maiores clientes)');
      }
    } else {
      console.log('üí¨ Prompt subsequente - Usando hist√≥rico existente');
    }

    const chat = model.startChat({
      history: chatHistory,
    });

    // Usar streaming com contexto
    const result = await chat.sendMessageStream(messageWithContext);

    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      async start(controller) {
        try {
          for await (const chunk of result.stream) {
            const text = chunk.text();
            const data = `data: ${JSON.stringify({ text })}\n\n`;
            controller.enqueue(encoder.encode(data));
          }
          controller.enqueue(encoder.encode('data: [DONE]\n\n'));
          controller.close();
        } catch (error) {
          controller.error(error);
        }
      },
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  } catch (error) {
    console.error('Erro no chat Gemini:', error);
    return new Response(JSON.stringify({ error: 'Erro ao processar mensagem' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}